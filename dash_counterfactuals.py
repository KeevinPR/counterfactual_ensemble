import dash
from dash import dcc, html, Input, Output, State
import dash_bootstrap_components as dbc
import pandas as pd
import base64
import io
from dash_ag_grid import AgGrid
import numpy as np
from sklearn.model_selection import train_test_split
from ensemble_counterfactuals.common_funcs import train_models
from ensemble_counterfactuals.algorithms import ga, eda, moeda, nsga2, ebna, moebna
import rpy2.robjects as robjects
from rpy2.robjects import pandas2ri, default_converter
from rpy2.robjects.conversion import localconverter

# Activate the pandas2ri conversion globally
pandas2ri.activate()

# Initialize the Dash app
app = dash.Dash(
    __name__,
    external_stylesheets=[dbc.themes.BOOTSTRAP],
    requests_pathname_prefix='/Reasoning/CounterfactualsDash/',
    suppress_callback_exceptions=True
)
server = app.server

# Global variable to store the uploaded DataFrame
uploaded_df = pd.DataFrame()

# Layout of the application
app.layout = html.Div([
    dcc.Loading(
        id="global-spinner",
        overlay_style={"visibility": "visible", "filter": "blur(1px)"},
        type="circle",  # You can choose "circle", "dot", "default", etc.
        fullscreen=False,
        children=html.Div([
            # Upload Dataset Section
            html.H1("Counterfactuals", style={'textAlign': 'center'}),

            ########################################################
            # Info text
            ########################################################
            html.Div(
                className="link-bar",
                style={
                    "textAlign": "center",
                    "marginBottom": "20px"
                },
                children=[
                    html.A(
                        children=[
                            html.Img(
                                src="https://cig.fi.upm.es/wp-content/uploads/github.png",
                                style={"height": "24px", "marginRight": "8px"}
                            ),
                            "Original GitHub"
                        ],
                        href="https://github.com/DanielZaragozaP/counterfactual_ensemble",
                        target="_blank",
                        className="btn btn-outline-info me-2"
                    ),
                    html.A(
                        children=[
                            html.Img(
                                src="https://cig.fi.upm.es/wp-content/uploads/2023/11/cropped-logo_CIG.png",
                                style={"height": "24px", "marginRight": "8px"}
                            ),
                            "Paper PDF"
                        ],
                        href="https://cig.fi.upm.es/wp-content/uploads/zaragoza-pellicer24a.pdf",
                        target="_blank",
                        className="btn btn-outline-primary me-2"
                    ),
                    html.A(
                        children=[
                            html.Img(
                                src="https://cig.fi.upm.es/wp-content/uploads/github.png",
                                style={"height": "24px", "marginRight": "8px"}
                            ),
                            "Dash Adapted GitHub"
                        ],
                        href="https://github.com/KeevinPR/counterfactual_ensemble",
                        target="_blank",
                        className="btn btn-outline-info me-2"
                    ),
                ]
            ),
            ########################################################
            # Short explanatory text
            ########################################################
            html.Div(
                [
                    html.P(
                        "Welcome to the Multi-objective Counterfactuals in Bayesian Classifiers with "
                        "Estimation of Distribution Algorithms. Below, you can upload your dataset, "
                        "and explore the counterfactuals generated by the EDAs algorithms.",
                        style={"textAlign": "center", "maxWidth": "800px", "margin": "0 auto"}
                    )
                ],
                style={"marginBottom": "20px"}
            ),

            ########################################################
            # (A) Data upload
            ########################################################
            html.Div(className="card", children=[
                html.H3("1. Upload Dataset" ,style={'textAlign': 'center'}),

                # Container "card"
                    html.Div([
                        # Top part with icon and text
                        html.Div([
                            html.Img(
                                src="https://img.icons8.com/ios-glyphs/40/cloud--v1.png",  
                                className="upload-icon"
                            ),
                            html.Div("Drag and drop or select a CSV file", className="upload-text")
                        ]),
                        
                        # Upload component
                        dcc.Upload(
                            id='upload-data',
                            children=html.Div([], style={'display': 'none'}),
                            className="upload-dropzone",
                            multiple=False
                        ),
                    ], className="upload-card"),

                # Use default dataset + help icon
                html.Div([
                    dcc.Checklist(
                        id='use-default-dataset',
                        options=[{'label': 'Use the default dataset', 'value': 'default'}],
                        value=[],
                        style={'display': 'inline-block', 'textAlign': 'center', 'marginTop': '10px'}
                    ),
                    dbc.Button(
                        html.I(className="fa fa-question-circle"),
                        id="help-button-default-dataset",
                        color="link",
                        style={"display": "inline-block", "marginLeft": "8px"}
                    ),
                ], style={'textAlign': 'center'}),
            ]),

            # Table of predictor variables
            html.Div(className="card-big", children=[
                html.H3("2. Predictor Variables", style={'textAlign': 'center'}),
                html.Div([
                    AgGrid(
                        id='predictor-table',
                        columnDefs=[],  # Column Definitions will be filled after file upload
                        rowData=[],     # Data will be filled after file upload
                        defaultColDef={'editable': False, 'resizable': True, 'sortable': True},
                        dashGridOptions={'rowSelection': 'single'},
                        style={'height': '300px'}
                    )
                ], style={'display': 'flex', 'justifyContent': 'center'})
            ], id='predictor-container', style={'display': 'none'}),

            html.Br(),

            # Selected Row and Class Modification Section
            html.Div(className="card-big", children=[
                html.Div([
                    html.H3("3. Selected Row", style={'textAlign': 'center'}),
                    html.Div([
                        AgGrid(
                            id='selected-row-table',
                            columnDefs=[],
                            rowData=[],
                            defaultColDef={'editable': False, 'resizable': True}
                        )
                    ], style={'display': 'flex', 'justifyContent': 'center'})
                ], id='selected-row-container', style={'display': 'none'})
            ]),
            
            html.Div(className="card", children=[
                html.H3("4. Select Class", style={'textAlign': 'center'}),
                html.Div([
                    dcc.Dropdown(id='class-selector')
                ], style={'width': '200px', 'margin': '0 auto', 'position': 'relative', 'zIndex': '9999'})
            ], id='class-container', style={'display': 'none'}),
             
            # Number of Models and Run Button
            html.Div([
                html.Div([
                        html.Button('Run', id='run-button', n_clicks=0)
                    ], style={'textAlign': 'center'}),
                    dcc.Store(id='run-button-store'),
                html.P("Models that will be use:", 
                           style={'textAlign': 'center', 'fontSize': '12px'}),
                html.P("nb, tn, fssj, kdb, tanhc, baseline",
                           style={'textAlign': 'center', 'fontSize': '10px'}),
            ], id='model-container', style={'display': 'none'}),

            # Results Table
            html.Div(className="card-big", children=[
                html.H3("Results", style={'textAlign': 'center'}),
                html.Div([
                    AgGrid(
                        id='results-table',
                        columnDefs=[],
                        rowData=[],
                        defaultColDef={'resizable': True}
                    )
                ], style={'display': 'flex', 'justifyContent': 'center'})
            ], id='results-container', style={'display': 'none'}),

            # Div for automatic scrolling down
            html.Div(id='scroll-helper', style={'display': 'none'})
        ])
    ),  # end of dcc.Loading

    # Popover **outside** the dcc.Loading
    dbc.Popover(
        [
            dbc.PopoverHeader(
                [
                    "Help",
                    html.I(className="fa fa-info-circle ms-2", style={"color": "#0d6efd"})
                ],
                style={
                    "backgroundColor": "#f8f9fa",  # Light gray background
                    "fontWeight": "bold"
                }
            ),
            dbc.PopoverBody(
                [
                    html.P(
                        [
                            "For details and content of the dataset, check out: ",
                            html.A(
                                "carwithnames.data",
                                href="https://github.com/KeevinPR/counterfactual_ensemble/blob/main/carwithnames.data",
                                target="_blank",
                                style={"textDecoration": "underline", "color": "#0d6efd"}
                            ),
                        ]
                    ),
                    html.Hr(),  # Horizontal rule for a modern divider
                    html.P("Feel free to upload your own dataset at any time.")
                ],
                style={
                    "backgroundColor": "#ffffff",
                    "borderRadius": "0 0 0.25rem 0.25rem"
                }
            ),
        ],
        id="help-popover-default-dataset",
        target="help-button-default-dataset",
        placement="right",
        is_open=False,
        trigger="hover"
    ),
dcc.Store(id='cleaned-data-store'),

])

# Automix scrolling down
app.clientside_callback(
    """
    function(selectedRowStyle, resultsStyle) {
        // Check if the 'Selected Row' container is visible
        if (selectedRowStyle && selectedRowStyle.display === 'block') {
            document.getElementById('selected-row-container').scrollIntoView({behavior: 'smooth'});
        }
        // Check if the 'Results' container is visible
        else if (resultsStyle && resultsStyle.display === 'block') {
            document.getElementById('results-container').scrollIntoView({behavior: 'smooth'});
        }
        return '';
    }
    """,
    Output('scroll-helper', 'children'),
    [Input('selected-row-container', 'style'),
     Input('results-container', 'style')]
)

# NEW Callback: Use default dataset -> sets 'upload-data.contents' (no ID changes!)
@app.callback(
    Output('upload-data', 'contents'),
    Input('use-default-dataset', 'value'),
    prevent_initial_call=True
)
def use_default_dataset(value):
    """
    If 'default' is checked, read your local 'carwithnames.data' file,
    encode as base64, and set upload-data.contents. This triggers
    the existing 'update_predictor_table' callback automatically.
    """
    if 'default' in value:
        default_file = '/var/www/html/CIGModels/backend/cigmodelsdjango/cigmodelsdjangoapp/Counterfactuals/carwithnames.data'  # Adjust path as needed
        try:
            with open(default_file, 'rb') as f:
                raw = f.read()
            b64 = base64.b64encode(raw).decode()
            return f"data:text/csv;base64,{b64}"
        except Exception as e:
            print(f"Error reading default dataset: {e}")
            return dash.no_update
    return dash.no_update

# Callback to update the predictor table
@app.callback(
    [Output('predictor-table', 'rowData'),
     Output('predictor-table', 'columnDefs'),
     Output('predictor-table', 'style'),
     Output('predictor-container', 'style')],
    Input('upload-data', 'contents'),
    State('upload-data', 'filename')
)
def update_predictor_table(contents, filename):
    if contents is not None:
        df = parse_contents(contents, filename if filename else "default.csv")
        if df is None:
            return [], [], {'height': '400px', 'width': '100%'}, {'display': 'none'}
        
        # Reset index to create 'Row Number' column
        df = df.reset_index(drop=False)
        df.rename(columns={'index': 'Row Number'}, inplace=True)
        
        columns = [{'headerName': col, 'field': col, 'width': 120} for col in df.columns]
        data = df.to_dict('records')
        total_width = sum([col['width'] for col in columns])
        return data, columns, {'height': '400px', 'width': f'{total_width}px'}, {'display': 'block'}
    else:
        return [], [], {'height': '400px', 'width': '100%'}, {'display': 'none'}

# Callback to display selected row and update class options
@app.callback(
    [Output('selected-row-table', 'rowData'),
     Output('selected-row-table', 'columnDefs'),
     Output('selected-row-table', 'style'),
     Output('selected-row-container', 'style'),
     Output('class-selector', 'options'),
     Output('class-selector', 'value'),
     Output('class-container', 'style'),
     Output('model-container', 'style')],
    Input('predictor-table', 'selectedRows'),
    State('predictor-table', 'rowData')
)
def display_selected_row_and_class(selectedRows, data):
    if selectedRows:
        selected_row = selectedRows[0]
        # Exclude internal keys (starting with '_')
        row_data = [{k: v for k, v in selected_row.items() if not k.startswith('_')}]
        columns = [{'headerName': col, 'field': col, 'width': 120} for col in row_data[0].keys()]
        total_width = sum([col['width'] for col in columns])

        # Extract class options for dropdown
        if 'class' in selected_row :
            class_options = [{'label': cls, 'value': cls} for cls in sorted({row['class'] for row in data})]
            class_value = selected_row['class']
            return (
                row_data,
                columns,
                {'height': '100px', 'width': f'{total_width}px'},
                {'display': 'block'},
                class_options,
                class_value,
                {'display': 'block'},
                {'display': 'block'}
            )
    return [], [], {}, {'display': 'none'}, [], None, {'display': 'none'}, {'display': 'none'}

# Callback for counterfactual generation
@app.callback(
    [Output('results-table', 'rowData'),
     Output('results-table', 'columnDefs'),
     Output('results-table', 'style'),
     Output('results-container', 'style'),
     Output('run-button', 'disabled'),
     Output('run-button-store', 'data')],
    Input('run-button', 'n_clicks'),
    State('predictor-table', 'selectedRows'),
    State('class-selector', 'value'),
    State('upload-data', 'contents')
)
def run_counterfactual(n_clicks, selectedRows, new_class, contents):
    num_models = 5
    if n_clicks is None or n_clicks == 0 or not selectedRows or new_class is None or contents is None:
        return [], [], {}, {'display': 'none'}, False, None  # Button enabled
    
    # Disable the "Run" button during processing
    disabled = True
    
    try:
        # Parse the uploaded data
        filename = 'temp_data.csv'  # Temporary filename
        df = parse_contents(contents, filename)
    
        # Check if data loaded correctly
        if df is None or df.empty:
            print("Error: The data was not loaded correctly.")
            return [], [], {}, {'display': 'none'}, False, None  # Button enabled
    
        # Process the selected row
        selected_row = selectedRows[0]
        # Exclude internal keys and 'Row Number'
        selected_row_clean = {k: v for k, v in selected_row.items() if not k.startswith('_') and k != 'Row Number'}
    
        # Validate input levels
        if not validate_input_levels(df, selected_row_clean):
            print("Error: Levels in the selected instance do not match levels in the loaded data.")
            return [], [], {}, {'display': 'none'}, False, None  # Button enabled
    
        # Generate counterfactuals
        df_counterfactual = generate_counterfactuals(selected_row_clean, new_class, num_models, df)
    
        # Check if counterfactuals were generated
        if df_counterfactual is not None and not df_counterfactual.empty:
            # Prepare the results table
            data = df_counterfactual.to_dict('records')
            columns = [{'headerName': col, 'field': col, 'width': 100} for col in df_counterfactual.columns]
            total_width = sum([col['width'] for col in columns])
            # Re-enable the "Run" button and update the store
            disabled = False
            return data, columns, {'height': '300px', 'width': f'{total_width}px'}, {'display': 'block'}, disabled, 'done'
        else:
            # Re-enable the "Run" button and update the store
            disabled = False
            return [], [], {}, {'display': 'none'}, disabled, 'done'
    except Exception as e:
        # Log the error
        print(f"Error generating counterfactuals: {e}")
        # Re-enable the "Run" button and update the store
        disabled = False
        return [], [], {}, {'display': 'none'}, disabled, 'done'

def validate_input_levels(df, selected_row):
    """
    Validates that the levels in the selected instance match
    those present in the loaded DataFrame.
    """
    for col in selected_row:
        if col in df.columns and selected_row[col] not in df[col].unique():
            return False
    return True

def preprocess_data(df):
    # Handle missing values
    df = df.dropna()
    # Convert all columns to 'category' dtype
    for col in df.columns:
        df[col] = df[col].astype('category')
    return df, df.columns.tolist()

def determine_discrete_variables(df):
    # Example function if needed
    discrete_vars = [True] * (df.shape[1] - 1)  # Exclude 'class' column
    return discrete_vars

def generate_counterfactuals(selected_row, new_class, num_models, df):
    import pandas as pd
    import numpy as np
    from sklearn.model_selection import train_test_split

    # 1) Preprocess data => all category
    df = df.dropna()  # already called? fine
    for c in df.columns:
        df[c] = df[c].astype('category')

    # 2) Train/test split
    train_df, test_df = train_test_split(df, test_size=0.1, random_state=42)

    # 3) Convert selected row to a DataFrame
    selected_row_df = pd.DataFrame([selected_row])

    #    (A) If the selected_row is missing any columns from df, add them as None
    #        This ensures selected_row_df has all columns that df has.
    for col in df.columns:
        if col not in selected_row_df.columns:
            selected_row_df[col] = None
        selected_row_df[col] = selected_row_df[col].astype('category')
        selected_row_df[col] = selected_row_df[col].cat.set_categories(df[col].cat.categories)

    #    (B) Now unify columns exactly:
    #        Force train_df/test_df to the exact same column order as df
    train_df = train_df[df.columns]
    test_df  = test_df[df.columns]
    selected_row_df = selected_row_df[df.columns]

    # 4) Convert all to string for R code
    train_df_str = train_df.astype(str)
    test_df_str  = test_df.astype(str)
    selected_row_str = selected_row_df.astype(str)

    # 5) Discrete variables: e.g. one less than total, ignoring 'class'
    discrete_variables = [True] * (df.shape[1] - 1)

    # 6) Call your EDA-based method
    try:
        df_result, _, accuracy, time_taken = eda.ensemble_counter_eda(
            X=train_df_str,
            input=selected_row_str.iloc[0].values,
            obj_class=new_class,
            test=test_df_str,
            discrete_variables=discrete_variables,
            verbose=True,
            no_train=True
        )
    except Exception as e:
        print(f"Error in ensemble_counter_eda: {e}")
        return None

    if df_result is not None and not df_result.empty:
        return df_result
    else:
        return None

# Function to parse and clean the uploaded dataset
import re
import numpy as np
import pandas as pd

def parse_contents(contents, filename):
    """
    Minimal parsing:
     1) Decode base64
     2) Read CSV or Excel
     3) If we find 'Class' in any case variant, rename it to 'class'
     4) Return the raw DataFrame (or None on error)
    """
    if not contents:
        return None
    try:
        # Decode base64
        content_type, content_string = contents.split(',')
        decoded = base64.b64decode(content_string)

        # Read file
        if any(ext in filename.lower() for ext in ['.csv', '.data', '.txt']):
            df = pd.read_csv(io.StringIO(decoded.decode('utf-8')), na_values='?')
        elif any(ext in filename.lower() for ext in ['.xls', '.xlsx']):
            df = pd.read_excel(io.BytesIO(decoded), na_values='?')
        else:
            print("Unsupported extension.")
            return None

        # If 'Class' or 'CLASS' in columns, rename it to 'class'
        possible_class = [c for c in df.columns if c.lower() == 'class']
        if possible_class:
            actual_name = possible_class[0]
            if actual_name != 'class':
                df.rename(columns={actual_name: 'class'}, inplace=True)

        # Reset index
        df.reset_index(drop=True, inplace=True)
        return df
    except Exception as e:
        print(f"Error in parse_and_clean: {e}")
        return None

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=8050)
import dash
from dash import dcc, html, Input, Output, State
import dash_bootstrap_components as dbc
import pandas as pd
import base64
import io
from dash_ag_grid import AgGrid
import numpy as np
from sklearn.model_selection import train_test_split
from ensemble_counterfactuals.common_funcs import train_models
from ensemble_counterfactuals.algorithms import ga, eda, moeda, nsga2, ebna, moebna
import rpy2.robjects as robjects
from rpy2.robjects import pandas2ri, default_converter
from rpy2.robjects.conversion import localconverter

# Activate the pandas2ri conversion globally
pandas2ri.activate()

# Initialize the Dash app
app = dash.Dash(
    __name__,
    external_stylesheets=[dbc.themes.BOOTSTRAP],
    requests_pathname_prefix='/Reasoning/CounterfactualsDash/',
    suppress_callback_exceptions=True
)
server = app.server

# Global variable to store the uploaded DataFrame
uploaded_df = pd.DataFrame()

# Layout of the application
app.layout = html.Div([
    dcc.Loading(
        id="global-spinner",
        overlay_style={"visibility": "visible", "filter": "blur(1px)"},
        type="circle",  # You can choose "circle", "dot", "default", etc.
        fullscreen=False,
        children=html.Div([
            # Upload Dataset Section
            html.H1("Counterfactuals", style={'textAlign': 'center'}),

            ########################################################
            # Info text
            ########################################################
            html.Div(
                className="link-bar",
                style={
                    "textAlign": "center",
                    "marginBottom": "20px"
                },
                children=[
                    html.A(
                        children=[
                            html.Img(
                                src="https://cig.fi.upm.es/wp-content/uploads/github.png",
                                style={"height": "24px", "marginRight": "8px"}
                            ),
                            "Original GitHub"
                        ],
                        href="https://github.com/DanielZaragozaP/counterfactual_ensemble",
                        target="_blank",
                        className="btn btn-outline-info me-2"
                    ),
                    html.A(
                        children=[
                            html.Img(
                                src="https://cig.fi.upm.es/wp-content/uploads/2023/11/cropped-logo_CIG.png",
                                style={"height": "24px", "marginRight": "8px"}
                            ),
                            "Paper PDF"
                        ],
                        href="https://cig.fi.upm.es/wp-content/uploads/zaragoza-pellicer24a.pdf",
                        target="_blank",
                        className="btn btn-outline-primary me-2"
                    ),
                    html.A(
                        children=[
                            html.Img(
                                src="https://cig.fi.upm.es/wp-content/uploads/github.png",
                                style={"height": "24px", "marginRight": "8px"}
                            ),
                            "Dash Adapted GitHub"
                        ],
                        href="https://github.com/KeevinPR/counterfactual_ensemble",
                        target="_blank",
                        className="btn btn-outline-info me-2"
                    ),
                ]
            ),
            ########################################################
            # Short explanatory text
            ########################################################
            html.Div(
                [
                    html.P(
                        "Welcome to the Multi-objective Counterfactuals in Bayesian Classifiers with "
                        "Estimation of Distribution Algorithms. Below, you can upload your dataset, "
                        "and explore the counterfactuals generated by the EDAs algorithms.",
                        style={"textAlign": "center", "maxWidth": "800px", "margin": "0 auto"}
                    )
                ],
                style={"marginBottom": "20px"}
            ),

            ########################################################
            # (A) Data upload
            ########################################################
            html.Div(className="card", children=[
                # Title or subtitle for this section
                html.Div([
                    html.H3("1. Upload Dataset", style={"display": "inline-block", "marginRight": "10px", "textAlign": "center"}),
                    # Add help button right after the title
                    dbc.Button(
                        html.I(className="fa fa-question-circle"),
                        id="help-button-dataset-requirements",
                        color="link",
                        style={"display": "inline-block", "verticalAlign": "middle", "padding": "0", "marginLeft": "5px"}
                    ),
                ], style={"textAlign": "center", "position": "relative"}),

                # Container "card"
                    html.Div([
                        # Top part with icon and text
                        html.Div([
                            html.Img(
                                src="https://img.icons8.com/ios-glyphs/40/cloud--v1.png",  
                                className="upload-icon"
                            ),
                            html.Div("Drag and drop or select a CSV file", className="upload-text")
                        ]),
                        
                        # Upload component
                        dcc.Upload(
                            id='upload-data',
                            children=html.Div([], style={'display': 'none'}),
                            className="upload-dropzone",
                            multiple=False
                        ),
                    ], className="upload-card"),

                # Use default dataset + help icon
                html.Div([
                    dcc.Checklist(
                        id='use-default-dataset',
                        options=[{'label': 'Use the default dataset', 'value': 'default'}],
                        value=[],
                        style={'display': 'inline-block', 'textAlign': 'center', 'marginTop': '10px'}
                    ),
                    dbc.Button(
                        html.I(className="fa fa-question-circle"),
                        id="help-button-default-dataset",
                        color="link",
                        style={"display": "inline-block", "marginLeft": "8px"}
                    ),
                ], style={'textAlign': 'center'}),
            ]),

            # Add Dataset Requirements Popover
            dbc.Popover(
                [
                    dbc.PopoverHeader(
                        [
                            "Dataset Requirements",
                            html.I(className="fa fa-check-circle ms-2", style={"color": "#198754"})
                        ],
                        style={"backgroundColor": "#f8f9fa", "fontWeight": "bold"}
                    ),
                    dbc.PopoverBody(
                        [
                            html.Ul([
                                html.Li(
                                    children=[
                                        html.Strong("Format: "),
                                        "CSV, .data, or .dat files. Headers required. Auto-detects delimiter."
                                    ]
                                ),
                                html.Li(
                                    children=[
                                        html.Strong("Data Type: "),
                                        "All variables must be categorical/discrete. Numerical values will be automatically converted to categories."
                                    ]
                                ),
                                html.Li(
                                    children=[
                                        html.Strong("Class Variable: "),
                                        "Must have a column named 'class' containing the target variable. This column must be categorical."
                                    ]
                                ),
                                html.Li(
                                    children=[
                                        html.Strong("Missing Values: "),
                                        "Use '?' symbol. Rows with any missing values will be removed. Columns with >30% missing values will be removed."
                                    ]
                                ),
                                html.Li(
                                    children=[
                                        html.Strong("Data Cleaning: "),
                                        "The following will be automatically removed: constant columns, columns with >30% missing values, and perfectly correlated features."
                                    ]
                                ),
                                html.Li(
                                    children=[
                                        html.Strong("Levels Validation: "),
                                        "When selecting an instance for counterfactual generation, all its categorical levels must exist in the training data."
                                    ]
                                ),
                            ]),
                        ],
                        style={"backgroundColor": "#ffffff", "borderRadius": "0 0 0.25rem 0.25rem", "maxWidth": "300px"}
                    ),
                ],
                id="help-popover-dataset-requirements",
                target="help-button-dataset-requirements",
                placement="right",
                is_open=False,
                trigger="hover",
                style={"position": "absolute", "zIndex": 1000, "marginLeft": "5px"}
            ),

            # Table of predictor variables
            html.Div(className="card-big", children=[
                html.Div([
                    html.H3("2. Predictor Variables", style={'display': 'inline-block', 'marginRight': '10px', 'textAlign': 'center'}),
                    dbc.Button(
                        html.I(className="fa fa-question-circle"),
                        id="help-button-predictor-variables",
                        color="link",
                        style={"display": "inline-block", "verticalAlign": "middle", "padding": "0", "marginLeft": "5px"}
                    ),
                ], style={"textAlign": "center", "position": "relative"}),
                html.Div([
                    AgGrid(
                        id='predictor-table',
                        columnDefs=[],  # Column Definitions will be filled after file upload
                        rowData=[],     # Data will be filled after file upload
                        defaultColDef={'editable': False, 'resizable': True, 'sortable': True},
                        dashGridOptions={'rowSelection': 'single'},
                        style={'height': '300px'}
                    )
                ], style={'display': 'flex', 'justifyContent': 'center'})
            ], id='predictor-container', style={'display': 'none'}),

            html.Br(),

            # Selected Row and Class Modification Section
            html.Div(className="card-big", children=[
                html.Div([
                    html.H3("3. Selected Row", style={'textAlign': 'center'}),
                    html.Div([
                        AgGrid(
                            id='selected-row-table',
                            columnDefs=[],
                            rowData=[],
                            defaultColDef={'editable': False, 'resizable': True}
                        )
                    ], style={'display': 'flex', 'justifyContent': 'center'})
                ], id='selected-row-container', style={'display': 'none'})
            ]),
            
            html.Div(className="card", children=[
                html.Div([
                    html.H3("4. Select Class", style={'display': 'inline-block', 'marginRight': '10px', 'textAlign': 'center'}),
                    dbc.Button(
                        html.I(className="fa fa-question-circle"),
                        id="help-button-select-class",
                        color="link",
                        style={"display": "inline-block", "verticalAlign": "middle", "padding": "0", "marginLeft": "5px"}
                    ),
                ], style={"textAlign": "center", "position": "relative"}),
                html.Div([
                    dcc.Dropdown(id='class-selector')
                ], style={'width': '200px', 'margin': '0 auto', 'position': 'relative', 'zIndex': '9999'})
            ], id='class-container', style={'display': 'none'}),
             
            # Number of Models and Run Button
            html.Div([
                html.Div([
                        html.Button('Run', id='run-button', n_clicks=0)
                    ], style={'textAlign': 'center'}),
                    dcc.Store(id='run-button-store'),
                html.P("Models that will be use:", 
                           style={'textAlign': 'center', 'fontSize': '12px'}),
                html.P("nb, tn, fssj, kdb, tanhc, baseline",
                           style={'textAlign': 'center', 'fontSize': '10px'}),
            ], id='model-container', style={'display': 'none'}),

            # Results Table
            html.Div(className="card-big", children=[
                html.Div([
                    html.H3("Results", style={'display': 'inline-block', 'marginRight': '10px', 'textAlign': 'center'}),
                    dbc.Button(
                        html.I(className="fa fa-question-circle"),
                        id="help-button-results",
                        color="link",
                        style={"display": "inline-block", "verticalAlign": "middle", "padding": "0", "marginLeft": "5px"}
                    ),
                ], style={"textAlign": "center", "position": "relative"}),
                html.Div([
                    AgGrid(
                        id='results-table',
                        columnDefs=[],
                        rowData=[],
                        defaultColDef={'resizable': True}
                    )
                ], style={'display': 'flex', 'justifyContent': 'center'})
            ], id='results-container', style={'display': 'none'}),

            # Div for automatic scrolling down
            html.Div(id='scroll-helper', style={'display': 'none'})
        ])
    ),  # end of dcc.Loading

    # Popovers **outside** the dcc.Loading
    dbc.Popover(
        [
            dbc.PopoverHeader(
                [
                    "Help",
                    html.I(className="fa fa-info-circle ms-2", style={"color": "#0d6efd"})
                ],
                style={
                    "backgroundColor": "#f8f9fa",
                    "fontWeight": "bold"
                }
            ),
            dbc.PopoverBody(
                [
                    html.P(
                        [
                            "For details and content of the dataset, check out: ",
                            html.A(
                                "carwithnames.data",
                                href="https://github.com/KeevinPR/counterfactual_ensemble/blob/main/carwithnames.data",
                                target="_blank",
                                style={"textDecoration": "underline", "color": "#0d6efd"}
                            ),
                        ]
                    ),
                    html.Hr(),
                    html.P("Feel free to upload your own dataset at any time.")
                ],
                style={
                    "backgroundColor": "#ffffff",
                    "borderRadius": "0 0 0.25rem 0.25rem"
                }
            ),
        ],
        id="help-popover-default-dataset",
        target="help-button-default-dataset",
        placement="right",
        is_open=False,
        trigger="hover"
    ),

    # New Popover for Predictor Variables
    dbc.Popover(
        [
            dbc.PopoverHeader(
                [
                    "Predictor Variables",
                    html.I(className="fa fa-info-circle ms-2", style={"color": "#0d6efd"})
                ],
                style={
                    "backgroundColor": "#f8f9fa",
                    "fontWeight": "bold"
                }
            ),
            dbc.PopoverBody(
                [
                    html.P("Select a row from the table to generate counterfactuals for that instance."),
                    html.P("The selected row will be used as the starting point for generating alternative scenarios."),
                    html.P("You can sort and filter the table to find specific instances."),
                ],
                style={
                    "backgroundColor": "#ffffff",
                    "borderRadius": "0 0 0.25rem 0.25rem"
                }
            ),
        ],
        id="help-popover-predictor-variables",
        target="help-button-predictor-variables",
        placement="right",
        is_open=False,
        trigger="hover"
    ),

    # New Popover for Select Class
    dbc.Popover(
        [
            dbc.PopoverHeader(
                [
                    "Select Class",
                    html.I(className="fa fa-info-circle ms-2", style={"color": "#0d6efd"})
                ],
                style={
                    "backgroundColor": "#f8f9fa",
                    "fontWeight": "bold"
                }
            ),
            dbc.PopoverBody(
                [
                    html.P("Choose the target class you want to achieve for the selected instance."),
                    html.P("The counterfactual generation will try to find the minimum changes needed to reach this class."),
                    html.P("The dropdown shows all possible class values from your dataset."),
                ],
                style={
                    "backgroundColor": "#ffffff",
                    "borderRadius": "0 0 0.25rem 0.25rem"
                }
            ),
        ],
        id="help-popover-select-class",
        target="help-button-select-class",
        placement="right",
        is_open=False,
        trigger="hover"
    ),

    # New Popover for Results
    dbc.Popover(
        [
            dbc.PopoverHeader(
                [
                    "Results",
                    html.I(className="fa fa-info-circle ms-2", style={"color": "#0d6efd"})
                ],
                style={
                    "backgroundColor": "#f8f9fa",
                    "fontWeight": "bold"
                }
            ),
            dbc.PopoverBody(
                [
                    html.P("The results table shows the counterfactual instances generated by the algorithms."),
                    html.P("Each row represents a possible alternative scenario that would lead to your target class."),
                    html.P("The changes needed to reach the target class are highlighted in the table."),
                    html.P("You can compare different counterfactuals to find the most suitable solution for your needs."),
                ],
                style={
                    "backgroundColor": "#ffffff",
                    "borderRadius": "0 0 0.25rem 0.25rem"
                }
            ),
        ],
        id="help-popover-results",
        target="help-button-results",
        placement="right",
        is_open=False,
        trigger="hover"
    ),

dcc.Store(id='cleaned-data-store'),
dcc.Store(id='notification-store'),
html.Div(id='upload-alert', style={'marginTop': '10px'}),
html.Div(id='notification-container', style={
    'position': 'fixed',
    'bottom': '20px',
    'right': '20px',
    'zIndex': '1000',
    'width': '300px',
    'transition': 'all 0.3s ease-in-out',
    'transform': 'translateY(100%)',
    'opacity': '0'
}),

])

TARGET_COL = "class"  # "target class"
MODEL_FILES   = ["nb.rds", "tan.rds", "fssj.rds", "kdb.rds", "tanhc.rds"]
FEATURES_FILE = "model_features.txt"          # save the column names of the model
robjects.globalenv['target_col'] = TARGET_COL
# Automix scrolling down
app.clientside_callback(
    """
    function(selectedRowStyle, resultsStyle) {
        // Check if the 'Selected Row' container is visible
        if (selectedRowStyle && selectedRowStyle.display === 'block') {
            // Find the h3 element containing "3. Selected Row"
            const headings = document.getElementsByTagName('h3');
            for (let heading of headings) {
                if (heading.textContent.includes('3. Selected Row')) {
                    // Get the element's position relative to the viewport
                    const elementPosition = heading.getBoundingClientRect().top;
                    // Get the current scroll position
                    const offsetPosition = elementPosition + window.pageYOffset - 100; // 100px offset for navbar
                    
                    window.scrollTo({
                        top: offsetPosition,
                        behavior: 'smooth'
                    });
                    break;
                }
            }
        }
        // Check if the 'Results' container is visible
        else if (resultsStyle && resultsStyle.display === 'block') {
            const resultsContainer = document.getElementById('results-container');
            const elementPosition = resultsContainer.getBoundingClientRect().top;
            const offsetPosition = elementPosition + window.pageYOffset - 100; // 100px offset for navbar
            
            window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
            });
        }
        return '';
    }
    """,
    Output('scroll-helper', 'children'),
    [Input('selected-row-container', 'style'),
     Input('results-container', 'style')]
)

# NEW Callback: Use default dataset -> sets 'upload-data.contents' (no ID changes!)
@app.callback(
    Output('upload-data', 'contents'),
    Input('use-default-dataset', 'value'),
    prevent_initial_call=True
)
def use_default_dataset(value):
    """
    If 'default' is checked, read your local 'carwithnames.data' file,
    encode as base64, and set upload-data.contents. This triggers
    the existing 'update_predictor_table' callback automatically.
    """
    if 'default' in value:
        default_file = '/var/www/html/CIGModels/backend/cigmodelsdjango/cigmodelsdjangoapp/Counterfactuals/carwithnames.data'  # Adjust path as needed
        try:
            with open(default_file, 'rb') as f:
                raw = f.read()
            b64 = base64.b64encode(raw).decode()
            return f"data:text/csv;base64,{b64}"
        except Exception as e:
            print(f"Error reading default dataset: {e}")
            return dash.no_update
    return dash.no_update

# Callback to update the predictor table
@app.callback(
    [Output('predictor-table', 'rowData'),
     Output('predictor-table', 'columnDefs'),
     Output('predictor-table', 'style'),
     Output('predictor-container', 'style'),
     Output('notification-store', 'data')],
    Input('upload-data', 'contents'),
    State('upload-data', 'filename'),
    prevent_initial_call=True
)
def update_predictor_table(contents, filename):
    if contents is not None:
        try:
            df = parse_contents(contents, filename if filename else "default.csv")
            if df is None:
                return [], [], {'height': '400px', 'width': '100%'}, {'display': 'none'}, {
                    'header': 'Error',
                    'message': 'Could not read the dataset. Please check the file format.',
                    'icon': 'danger'
                }
            
            # Reset index to create 'Row Number' column
            df = df.reset_index(drop=False)
            df.rename(columns={'index': 'Row Number'}, inplace=True)
            
            columns = [{'headerName': col, 'field': col, 'width': 120} for col in df.columns]
            data = df.to_dict('records')
            total_width = sum([col['width'] for col in columns])
            
            return data, columns, {'height': '400px', 'width': f'{total_width}px'}, {'display': 'block'}, None
        except ValueError as e:
            return [], [], {'height': '400px', 'width': '100%'}, {'display': 'none'}, {
                'header': 'Error',
                'message': str(e),
                'icon': 'danger'
            }
        except Exception as e:
            return [], [], {'height': '400px', 'width': '100%'}, {'display': 'none'}, {
                'header': 'Error',
                'message': 'Could not process the dataset.',
                'icon': 'danger'
            }
    else:
        return [], [], {'height': '400px', 'width': '100%'}, {'display': 'none'}, None

# Callback to display selected row and update class options
@app.callback(
    [Output('selected-row-table', 'rowData'),
     Output('selected-row-table', 'columnDefs'),
     Output('selected-row-table', 'style'),
     Output('selected-row-container', 'style'),
     Output('class-selector', 'options'),
     Output('class-selector', 'value'),
     Output('class-container', 'style'),
     Output('model-container', 'style')],
    Input('predictor-table', 'selectedRows'),
    State('predictor-table', 'rowData')
)
def display_selected_row_and_class(selectedRows, data):
    if selectedRows:
        selected_row = selectedRows[0]
        # Exclude internal keys (starting with '_')
        row_data = [{k: v for k, v in selected_row.items() if not k.startswith('_')}]
        columns = [{'headerName': col, 'field': col, 'width': 120} for col in row_data[0].keys()]
        total_width = sum([col['width'] for col in columns])

        # Extract class options for dropdown
        if TARGET_COL in selected_row:
            class_options = [{'label': val, 'value': val}
                            for val in sorted({row[TARGET_COL] for row in data})]
            class_value = selected_row[TARGET_COL]
            return (
                row_data,
                columns,
                {'height': '100px', 'width': f'{total_width}px'},
                {'display': 'block'},
                class_options,
                class_value,
                {'display': 'block'},
                {'display': 'block'}
            )
    return [], [], {}, {'display': 'none'}, [], None, {'display': 'none'}, {'display': 'none'}

# Callback for counterfactual generation
@app.callback(
    [Output('results-table', 'rowData'),
     Output('results-table', 'columnDefs'),
     Output('results-table', 'style'),
     Output('results-container', 'style'),
     Output('run-button', 'disabled'),
     Output('run-button-store', 'data'),
     Output('notification-store', 'data', allow_duplicate=True)],
    Input('run-button', 'n_clicks'),
    State('predictor-table', 'selectedRows'),
    State('class-selector', 'value'),
    State('upload-data', 'contents'),
    prevent_initial_call=True
)
def run_counterfactual(n_clicks, selectedRows, new_class, contents):
    num_models = 5
    if n_clicks is None or n_clicks == 0 or not selectedRows or new_class is None or contents is None:
        return [], [], {}, {'display': 'none'}, False, None, None  # Button enabled
    
    # Disable the "Run" button during processing
    disabled = True
    
    try:
        # Parse the uploaded data
        filename = 'temp_data.csv'  # Temporary filename
        df = parse_contents(contents, filename)
    
        # Check if data loaded correctly
        if df is None or df.empty:
            return [], [], {}, {'display': 'none'}, False, None, {
                'header': 'Error',
                'message': 'Could not read the dataset. Please check the file format.',
                'icon': 'danger'
            }
    
        # Process the selected row
        selected_row = selectedRows[0]
        # Exclude internal keys and 'Row Number'
        selected_row_clean = {k: v for k, v in selected_row.items() if not k.startswith('_') and k != 'Row Number'}
    
        # Validate input levels
        if not validate_input_levels(df, selected_row_clean):
            return [], [], {}, {'display': 'none'}, False, None, {
                'header': 'Error',
                'message': 'Levels in the selected instance do not match levels in the loaded data.',
                'icon': 'danger'
            }
    
        # Generate counterfactuals
        try:
            df_counterfactual = generate_counterfactuals(selected_row_clean, new_class, num_models, df)
        except ValueError as e:
            # Re-enable the "Run" button and show the error message
            return [], [], {}, {'display': 'none'}, False, 'done', {
                'header': 'Error',
                'message': str(e),
                'icon': 'warning'
            }
        except Exception as e:
            # Re-enable the "Run" button and show the error message
            return [], [], {}, {'display': 'none'}, False, 'done', {
                'header': 'Error',
                'message': f'Error generating counterfactuals: {str(e)}',
                'icon': 'danger'
            }
    
        # Check if counterfactuals were generated
        if df_counterfactual is not None and not df_counterfactual.empty:
            # Prepare the results table
            data = df_counterfactual.to_dict('records')
            columns = [{'headerName': col, 'field': col, 'width': 100} for col in df_counterfactual.columns]
            total_width = sum([col['width'] for col in columns])
            # Re-enable the "Run" button and update the store
            disabled = False
            return data, columns, {'height': '300px', 'width': f'{total_width}px'}, {'display': 'block'}, disabled, 'done', None
        else:
            # Re-enable the "Run" button and update the store
            disabled = False
            return [], [], {}, {'display': 'none'}, disabled, 'done', {
                'header': 'No Counterfactuals Found',
                'message': 'Could not generate counterfactuals for the selected class. This may be because there are no plausible instances of this class in the dataset.',
                'icon': 'warning'
            }
    except Exception as e:
        # Log the error
        print(f"Error in run_counterfactual: {e}")
        # Re-enable the "Run" button and update the store
        disabled = False
        return [], [], {}, {'display': 'none'}, disabled, 'done', {
            'header': 'Error',
            'message': f'Error generating counterfactuals: {str(e)}',
            'icon': 'danger'
        }

def validate_input_levels(df, selected_row):
    """
    Validates that the levels in the selected instance match
    those present in the loaded DataFrame.
    """
    for col in selected_row:
        if col in df.columns and selected_row[col] not in df[col].unique():
            return False
    return True

def preprocess_data(df):
    # Handle missing values
    df = df.dropna()
    # Convert all columns to 'category' dtype
    for col in df.columns:
        df[col] = df[col].astype('category')
    return df, df.columns.tolist()



def generate_counterfactuals(selected_row, new_class, num_models, df):
    import pandas as pd
    import numpy as np
    from sklearn.model_selection import train_test_split
    # 1) Preprocess data => all category
    df = df.dropna()  # already called? fine
    for c in df.columns:
        df[c] = df[c].astype('category')

    # 2) Train/test split
    train_df, test_df = train_test_split(df, test_size=0.1, random_state=42)

    # 3) Convert selected row to a DataFrame
    selected_row_df = pd.DataFrame([selected_row])

    #    (A) If the selected_row is missing any columns from df, add them as None
    #        This ensures selected_row_df has all columns that df has.
    for col in df.columns:
        if col not in selected_row_df.columns:
            selected_row_df[col] = None
        selected_row_df[col] = selected_row_df[col].astype('category')
        selected_row_df[col] = selected_row_df[col].cat.set_categories(df[col].cat.categories)

    #    (B) Now unify columns exactly:
    #        Force train_df/test_df to the exact same column order as df
    train_df = train_df[df.columns]
    test_df  = test_df[df.columns]
    selected_row_df = selected_row_df[df.columns]

    # 4) Convert all to string for R code
    train_df_str = train_df.astype(str)
    test_df_str  = test_df.astype(str)
    selected_row_str = selected_row_df.astype(str)
    
    # 5) Discrete variables: set True for all columns,
    #    but set the target column to False because it is not a predictor.
    discrete_variables = [True] * df.shape[1]
    # Find the position (integer index) of the target column in df
    target_index = df.columns.get_loc(TARGET_COL)
    discrete_variables[target_index] = False

    # 6) Call your EDA-based method
    try:
        # Check if the target class exists in the dataset
        if new_class not in df[TARGET_COL].unique():
            raise ValueError(f"Target class '{new_class}' does not exist in the dataset.")

        # Check if there are enough examples of the target class
        target_class_count = len(df[df[TARGET_COL] == new_class])
        if target_class_count < 2:  # Need at least 2 examples for training
            raise ValueError(f"Not enough examples of class '{new_class}' in the dataset (found {target_class_count}).")

        # Check if the selected row's class matches the target class
        if selected_row[TARGET_COL] == new_class:
            raise ValueError(f"The selected instance already belongs to class '{new_class}'. No counterfactual needed.")

        try:
            df_result, remaing_models, accuracy, time_taken = eda.ensemble_counter_eda(
                X=train_df_str,
                input=selected_row_str.iloc[0].values,
                obj_class=new_class,
                test=test_df_str,
                discrete_variables=discrete_variables,
                verbose=True,
                no_train=True
            )
        except Exception as e:
            if "DataFrame constructor not properly called" in str(e):
                raise ValueError("Could not generate counterfactuals. This may be because the target class is not achievable from the current instance's characteristics.")
            raise
        
        # Check if any models were available
        if remaing_models[0] == 0:
            raise ValueError("No models available that can predict the target class correctly. This may be because the target class is not plausible for the selected instance.")
            
        # Check if any counterfactuals were found
        if df_result is None or df_result.empty:
            raise ValueError("No counterfactuals could be generated for the selected class. This may be because the target class is not achievable from the current instance.")
            
        return df_result
        
    except ValueError as e:
        print(f"Error in generate_counterfactuals: {e}")
        raise  # Re-raise the ValueError to be caught by the callback
    except Exception as e:
        print(f"Unexpected error in generate_counterfactuals: {e}")
        raise ValueError(f"An unexpected error occurred: {str(e)}")

# Function to parse and clean the uploaded dataset
import re
import numpy as np
import pandas as pd

def parse_contents(contents, filename):
    """
    Enhanced parsing for Counterfactuals:
    1) Decode base64
    2) Read CSV/Excel
    3) Clean and validate data
    4) Convert to categories
    5) Validate class column (case-insensitive)
    6) Return cleaned DataFrame
    """
    if not contents:
        return None
    try:
        # Decode base64
        content_type, content_string = contents.split(',')
        decoded = base64.b64decode(content_string)

        # Read file - try to read as CSV regardless of extension
        try:
            df = pd.read_csv(io.StringIO(decoded.decode('utf-8')), na_values='?')
        except Exception as e:
            # If reading as CSV fails, check if it's a supported extension
            if any(ext in filename.lower() for ext in ['.data', '.dat']):
                df = pd.read_csv(io.StringIO(decoded.decode('utf-8')), na_values='?')
            else:
                raise ValueError("Could not read the file. Please ensure it's a valid CSV, .data, or .dat file.")

        # Reset index
        df.reset_index(drop=True, inplace=True)
        
        # Check for class column (case insensitive)
        class_col = None
        for col in df.columns:
            if col.lower() == TARGET_COL.lower():
                class_col = col
                break
                
        if class_col is None:
            raise ValueError("Missing 'class' column (case-insensitive).")
            
        # Rename the class column to lowercase 'class' for consistency
        df = df.rename(columns={class_col: TARGET_COL})

        # Remove columns with too many missing values (>30%)
        missing_threshold = 0.3
        cols_to_drop = [col for col in df.columns if df[col].isna().mean() > missing_threshold]
        if cols_to_drop:
            df = df.drop(columns=cols_to_drop)

        # Remove rows with any missing values
        df = df.dropna()

        # Remove constant columns
        constant_cols = [col for col in df.columns if df[col].nunique() == 1]
        if constant_cols:
            df = df.drop(columns=constant_cols)

        # Remove perfectly correlated features
        corr_matrix = df.select_dtypes(include=['number']).corr().abs()
        upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))
        to_drop = [column for column in upper.columns if any(upper[column] > 0.99)]
        if to_drop:
            df = df.drop(columns=to_drop)

        # Convert all columns to categories
        for col in df.columns:
            df[col] = df[col].astype('category')

        # Move class column to end
        cols = [col for col in df.columns if col != TARGET_COL] + [TARGET_COL]
        df = df[cols]
            
        return df
    except Exception as e:
        print(f"Error in parse_contents: {e}")
        raise  # Re-raise the exception to be caught by the callback

# Callback for dataset requirements popover
@app.callback(
    Output("help-popover-dataset-requirements", "is_open"),
    Input("help-button-dataset-requirements", "n_clicks"),
    State("help-popover-dataset-requirements", "is_open")
)
def toggle_dataset_requirements_popover(n, is_open):
    if n:
        return not is_open
    return is_open

# Modificar el callback de notificaciones
@app.callback(
    [Output('notification-container', 'children'),
     Output('notification-container', 'style')],
    Input('notification-store', 'data')
)
def show_notification(data):
    if data is None:
        return None, {
            'position': 'fixed',
            'bottom': '20px',
            'right': '20px',
            'zIndex': '1000',
            'width': '300px',
            'transition': 'all 0.3s ease-in-out',
            'transform': 'translateY(100%)',
            'opacity': '0'
        }
    
    # Crear el toast con animación
    toast = dbc.Toast(
        data['message'],
        header=data['header'],
        icon=data['icon'],
        is_open=True,
        dismissable=True,
        style={
            'width': '100%',
            'boxShadow': '0 4px 6px rgba(0, 0, 0, 0.1)',
            'borderRadius': '8px',
            'marginBottom': '10px'
        }
    )
    
    # Estilo para mostrar la notificación con animación
    container_style = {
        'position': 'fixed',
        'bottom': '20px',
        'right': '20px',
        'zIndex': '1000',
        'width': '300px',
        'transition': 'all 0.3s ease-in-out',
        'transform': 'translateY(0)',
        'opacity': '1'
    }
    
    return toast, container_style

if __name__ == '__main__':
    app.run(debug=False, host='0.0.0.0', port=8050)